---
title: JS面经
lang: zh-CN
date: 2022-10-21 12:31:34
permalink: /guide/js/exp/
---

## 1.1 ES6，ES6新特性

ES6即ECMAScript 6，也称ES2015，是2015颁布的JS标准。ECMA是一个国际化标准组织，JS被提交到这里。

主要的新功能有：

1. 新语法，如加入`let`、`const`，扩展运算符和剩余参数`...`，解构，模板字面量，`Symbol`等
2. 代码模块化，支持`export`和`import`
3. 数字、字符串、正则新特性，如提供十六进制、添加`Number.isNaN()`（减少全局转换）、字符串`includes()`、`repeat()`函数等
4. 对象、数组新特性，如对象支持重复属性、数组支持`Array.of()`、`Array.from()`、引入`fill()`等新方法
5. 函数新特性，如箭头函数、默认参数等
6. 新增Set和Map数据结构
7. 新增迭代器和生成器，新增`for-of`循环
8. 支持`class`直接生成类
9. 新增`Promise`
10. 新增代理、反射

## 1.2 JS数据类型

基本类型：`number`、`boolean`、`string`、`null`、`undefined`、`symbol`、`bigint`。

引用类型：`object`，注意`array`、`function`也是对象。

### 1.2.1 `typeof`

可以使用`typeof`判断数据类型，它的返回值有：`"number"`、`"boolean"`、`"string"`、`"undefined"`、`"symbol"`、`"bigint"`、`"object"`、`"function"`。

- `NaN`、`Infinity`的`typeof`返回`"number"`
- 未定义的变量做`typeof`，不会报错，而返回`"undefined"`
- `null`的`typeof`返回`"object"`，`array`的`typeof`返回`"object"`（判断`array`可用`Array.isArray()`），基本类型的包装类对象的`typeof`返回`"object"`
- `class`的`typeof`返回`"function"`

对于函数、自定义类，需要用`instanceof`判断。

```javascript
console.log(typeof 1);  // number
console.log(typeof Infinity); // number
console.log(typeof NaN);  // number
console.log(typeof true); // boolean
console.log(typeof "1");  // string
console.log(typeof undefined);  // undefined
console.log(typeof x);  // undefined，未定义变量
console.log(typeof null); // object
console.log(typeof Symbol("a"));  // symbol
console.log(typeof 1n); // bigint
console.log(typeof {}); // object
console.log(typeof []); // object，数组也是对象
console.log(typeof new Number(1));  // object，复杂原始类型
console.log(typeof function() {});  // function
console.log(typeof class A {}); // function，类也是函数
```

### 1.2.2 `instanceof`

`instanceof`判断复杂原始类型、`object`、自定义数据类型。

- 简单原始类型只能用`typeof`，复杂原始类型只能用`instanceof`
- `function`用`typeof`、`instanceof`均可
- 对象、自定义类型用`typeof`均返回`"object"`，用`instanceof`可判断原型

```javascript
console.log(typeof 1);  // number
console.log(1 instanceof Number); // false
console.log(typeof new Number(1));  // object
console.log(new Number(1) instanceof Number); // true
console.log(typeof /a/);  // object，正则表达式也是对象
console.log(/a/ instanceof RegExp); // true
console.log(typeof {});  // object
console.log({} instanceof Object); // true
console.log(typeof []);  // object
console.log([] instanceof Array); // true
function Teacher() {}
function Student() {}
const teacher = new Teacher();
console.log(typeof teacher);  // object
console.log(teacher instanceof Teacher); // true
console.log(teacher instanceof Student); // false
console.log(teacher instanceof Object); // true，teacher -> Teacher.prototype -> Object.prototype
```

### 1.2.3 手写`instanceof`

循环使用`__proto__`或`Object.getPrototypeOf()`。

```javascript
function instanceOf(a, b) {
  if (typeof a !== 'object' && typeof a !== 'function') {
    return false; // 确保a不是基本类型
  }
  a = a ? a.__proto__ : null;
  while (true) {
    if (a === null) {
      return false;
    }
    if (a === b.prototype) {
      return true;
    }
    a = a.__proto__;
  }
}
```

### 1.2.4 `Object.prototype.toString.call()`

将`Object.prototype.toString()`用于其他变量，可以得到形如`"[object xxx]"`的字符串。

```javascript
console.log(Object.prototype.toString.call(1)); // [object Number]
console.log(Object.prototype.toString.call(true));  // [object Boolean]
console.log(Object.prototype.toString.call("1")); // [object String]
console.log(Object.prototype.toString.call(null)); // [object Null]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(Symbol("a"))); // [object Symbol]
console.log(Object.prototype.toString.call(1n));  // [object BigInt]
console.log(Object.prototype.toString.call([]));  // [object Array]
console.log(Object.prototype.toString.call({}));  // [object Object]
console.log(Object.prototype.toString.call(function() {})); // [object Function]
```

### 1.2.5 `constructor`

由于对象的原型（即`__proto__`属性指向的对象）有一个`constructor`属性指向构造函数，因此对象也可以调用它。基本类型也可以调用。

```javascript
console.log((1).constructor === Number);  // true
console.log(true.constructor === Boolean);  // true
console.log("1".constructor === String);  // true
// console.log(null.constructor); // TypeError: Cannot read property 'constructor' of null
// console.log(undefined.constructor);  // TypeError: Cannot read property 'constructor' of undefined
console.log(Symbol("a").constructor === Symbol);  // true
console.log(1n.constructor === BigInt);  // true
console.log([].constructor === Array);  // true
console.log({}.constructor === Object); // true
console.log(function() {}.constructor === Function);  // true
console.log(new Date().constructor === Date); // true
console.log(/a/.constructor === RegExp);  // true
class Teacher {}
console.log(new Teacher().constructor === Teacher); // true
```

## 1.3 变量声明、变量提升、作用域